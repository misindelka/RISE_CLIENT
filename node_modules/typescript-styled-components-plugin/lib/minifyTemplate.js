"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-10-29 13:16:38
 *
 * most of the code comes from
 *  {@link https://github.com/styled-components/babel-plugin-styled-components/blob/master/src/minify/index.js}
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.minifyTemplate = exports.minifyCookedValues = exports.minifyRawValues = exports.compressSymbols = exports.stripLineComment = void 0;
const tslib_1 = require("tslib");
const difference_1 = tslib_1.__importDefault(require("lodash/difference"));
const typescript_1 = tslib_1.__importDefault(require("typescript"));
// The capture group makes sure that the split contains the interpolation index
const placeholderRegex = /(?:__PLACEHOLDER_(\d+)__)/g;
// Alternative regex that splits without a capture group
const placeholderNonCapturingRegex = /__PLACEHOLDER_(?:\d+)__/g;
// Generates a placeholder from an index
const makePlaceholder = (index) => `__PLACEHOLDER_${index}__`;
// Splits CSS by placeholders
const splitByPlaceholders = ([css, ...rest], capture = true) => [
    css.split(capture ? placeholderRegex : placeholderNonCapturingRegex),
    ...rest,
];
const injectUniquePlaceholders = (strArr) => {
    let i = 0;
    return strArr.reduce((str, val, index, arr) => {
        return str + val + (index < arr.length - 1 ? makePlaceholder(i++) : '');
    }, '');
};
const makeMultilineCommentRegex = (newlinePattern) => new RegExp('\\/\\*[^!](.|' + newlinePattern + ')*?\\*\\/', 'g');
const lineCommentStart = /\/\//g;
const symbolRegex = /(\s*[;:{},]\s*)/g;
// Counts occurences of substr inside str
const countOccurences = (str, substr) => str.split(substr).length - 1;
// Joins substrings until predicate returns true
const reduceSubstr = (substrs, join, predicate) => {
    const length = substrs.length;
    let res = substrs[0];
    if (length === 1) {
        return res;
    }
    for (let i = 1; i < length; i++) {
        if (predicate(res)) {
            break;
        }
        res += join + substrs[i];
    }
    return res;
};
// Joins at comment starts when it's inside a string or parantheses
// effectively removing line comments
const stripLineComment = (line) => reduceSubstr(line.split(lineCommentStart), '//', (str) => !str.endsWith(':') && // NOTE: This is another guard against urls, if they're
    // not inside strings or parantheses.
    countOccurences(str, "'") % 2 === 0 &&
    countOccurences(str, '"') % 2 === 0 &&
    countOccurences(str, '(') === countOccurences(str, ')'));
exports.stripLineComment = stripLineComment;
const compressSymbols = (code) => code.split(symbolRegex).reduce((str, fragment, index) => {
    // Even-indices are non-symbol fragments
    if (index % 2 === 0) {
        return str + fragment;
    }
    // Only manipulate symbols outside of strings
    if (countOccurences(str, "'") % 2 === 0 &&
        countOccurences(str, '"') % 2 === 0) {
        return str + fragment.trim();
    }
    return str + fragment;
}, '');
exports.compressSymbols = compressSymbols;
// Detects lines that are exclusively line comments
const isLineComment = (line) => line.trim().startsWith('//');
// Creates a minifier with a certain linebreak pattern
const minify = (linebreakPattern) => {
    const linebreakRegex = new RegExp(linebreakPattern + '\\s*', 'g');
    const multilineCommentRegex = makeMultilineCommentRegex(linebreakPattern);
    return (code) => {
        const newCode = code
            .replace(multilineCommentRegex, '\n') // Remove multiline comments
            .split(linebreakRegex) // Split at newlines
            .filter((line) => line.length > 0 && !isLineComment(line)) // Removes
            // lines
            // containing
            // only line
            // comments
            .map(exports.stripLineComment) // Remove line comments inside text
            .join(' '); // Rejoin all lines
        const eliminatedExpressionIndices = difference_1.default(code.match(placeholderRegex), newCode.match(placeholderRegex)).map((x) => parseInt(x.match(/\d+/)[0], 10));
        return [exports.compressSymbols(newCode), eliminatedExpressionIndices];
    };
};
const minifyRaw = minify('(?:\\\\r|\\\\n|\\r|\\n)');
const minifyCooked = minify('[\\r\\n]');
const minifyRawValues = (rawValues) => splitByPlaceholders(minifyRaw(injectUniquePlaceholders(rawValues)), false);
exports.minifyRawValues = minifyRawValues;
const minifyCookedValues = (cookedValues) => splitByPlaceholders(minifyCooked(injectUniquePlaceholders(cookedValues)), false);
exports.minifyCookedValues = minifyCookedValues;
function minifyTemplate(node) {
    const cookedValues = [];
    const template = node.template;
    if (typescript_1.default.isNoSubstitutionTemplateLiteral(template)) {
        cookedValues.push(template.text);
    }
    else {
        cookedValues.push(template.head.text);
        template.templateSpans.forEach((span) => {
            cookedValues.push(span.literal.text);
        });
    }
    const [spans, indicates] = exports.minifyCookedValues(cookedValues);
    let newTemplate;
    if (typescript_1.default.isNoSubstitutionTemplateLiteral(template)) {
        newTemplate = typescript_1.default.factory.createNoSubstitutionTemplateLiteral(spans[0] || '');
    }
    else {
        const templateSpans = template.templateSpans.slice();
        indicates.forEach((expressionIndex, iteration) => {
            templateSpans.splice(expressionIndex - iteration, 1);
        });
        if (templateSpans.length === 0) {
            newTemplate = typescript_1.default.factory.createNoSubstitutionTemplateLiteral(spans[0] || '');
        }
        else {
            newTemplate = typescript_1.default.factory.createTemplateExpression(typescript_1.default.factory.createTemplateHead(spans[0]), templateSpans.map((span, index) => {
                return typescript_1.default.factory.createTemplateSpan(span.expression, index === spans.length - 2
                    ? typescript_1.default.factory.createTemplateTail(spans[index + 1])
                    : typescript_1.default.factory.createTemplateMiddle(spans[index + 1]));
            }));
        }
    }
    return typescript_1.default.factory.createTaggedTemplateExpression(node.tag, node.typeArguments, newTemplate);
}
exports.minifyTemplate = minifyTemplate;
//# sourceMappingURL=minifyTemplate.js.map