/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-10-29 13:16:38
 *
 * most of the code comes from
 *  {@link https://github.com/styled-components/babel-plugin-styled-components/blob/master/src/minify/index.js}
 */
import { __read, __spread } from "tslib";
import difference from 'lodash/difference';
import ts from 'typescript';
// The capture group makes sure that the split contains the interpolation index
var placeholderRegex = /(?:__PLACEHOLDER_(\d+)__)/g;
// Alternative regex that splits without a capture group
var placeholderNonCapturingRegex = /__PLACEHOLDER_(?:\d+)__/g;
// Generates a placeholder from an index
var makePlaceholder = function (index) { return "__PLACEHOLDER_" + index + "__"; };
// Splits CSS by placeholders
var splitByPlaceholders = function (_a, capture) {
    var _b = __read(_a), css = _b[0], rest = _b.slice(1);
    if (capture === void 0) { capture = true; }
    return __spread([
        css.split(capture ? placeholderRegex : placeholderNonCapturingRegex)
    ], rest);
};
var injectUniquePlaceholders = function (strArr) {
    var i = 0;
    return strArr.reduce(function (str, val, index, arr) {
        return str + val + (index < arr.length - 1 ? makePlaceholder(i++) : '');
    }, '');
};
var makeMultilineCommentRegex = function (newlinePattern) {
    return new RegExp('\\/\\*[^!](.|' + newlinePattern + ')*?\\*\\/', 'g');
};
var lineCommentStart = /\/\//g;
var symbolRegex = /(\s*[;:{},]\s*)/g;
// Counts occurences of substr inside str
var countOccurences = function (str, substr) {
    return str.split(substr).length - 1;
};
// Joins substrings until predicate returns true
var reduceSubstr = function (substrs, join, predicate) {
    var length = substrs.length;
    var res = substrs[0];
    if (length === 1) {
        return res;
    }
    for (var i = 1; i < length; i++) {
        if (predicate(res)) {
            break;
        }
        res += join + substrs[i];
    }
    return res;
};
// Joins at comment starts when it's inside a string or parantheses
// effectively removing line comments
export var stripLineComment = function (line) {
    return reduceSubstr(line.split(lineCommentStart), '//', function (str) {
        return !str.endsWith(':') && // NOTE: This is another guard against urls, if they're
            // not inside strings or parantheses.
            countOccurences(str, "'") % 2 === 0 &&
            countOccurences(str, '"') % 2 === 0 &&
            countOccurences(str, '(') === countOccurences(str, ')');
    });
};
export var compressSymbols = function (code) {
    return code.split(symbolRegex).reduce(function (str, fragment, index) {
        // Even-indices are non-symbol fragments
        if (index % 2 === 0) {
            return str + fragment;
        }
        // Only manipulate symbols outside of strings
        if (countOccurences(str, "'") % 2 === 0 &&
            countOccurences(str, '"') % 2 === 0) {
            return str + fragment.trim();
        }
        return str + fragment;
    }, '');
};
// Detects lines that are exclusively line comments
var isLineComment = function (line) { return line.trim().startsWith('//'); };
// Creates a minifier with a certain linebreak pattern
var minify = function (linebreakPattern) {
    var linebreakRegex = new RegExp(linebreakPattern + '\\s*', 'g');
    var multilineCommentRegex = makeMultilineCommentRegex(linebreakPattern);
    return function (code) {
        var newCode = code
            .replace(multilineCommentRegex, '\n') // Remove multiline comments
            .split(linebreakRegex) // Split at newlines
            .filter(function (line) { return line.length > 0 && !isLineComment(line); }) // Removes
            // lines
            // containing
            // only line
            // comments
            .map(stripLineComment) // Remove line comments inside text
            .join(' '); // Rejoin all lines
        var eliminatedExpressionIndices = difference(code.match(placeholderRegex), newCode.match(placeholderRegex)).map(function (x) { return parseInt(x.match(/\d+/)[0], 10); });
        return [compressSymbols(newCode), eliminatedExpressionIndices];
    };
};
var minifyRaw = minify('(?:\\\\r|\\\\n|\\r|\\n)');
var minifyCooked = minify('[\\r\\n]');
export var minifyRawValues = function (rawValues) {
    return splitByPlaceholders(minifyRaw(injectUniquePlaceholders(rawValues)), false);
};
export var minifyCookedValues = function (cookedValues) {
    return splitByPlaceholders(minifyCooked(injectUniquePlaceholders(cookedValues)), false);
};
export function minifyTemplate(node) {
    var cookedValues = [];
    var template = node.template;
    if (ts.isNoSubstitutionTemplateLiteral(template)) {
        cookedValues.push(template.text);
    }
    else {
        cookedValues.push(template.head.text);
        template.templateSpans.forEach(function (span) {
            cookedValues.push(span.literal.text);
        });
    }
    var _a = __read(minifyCookedValues(cookedValues), 2), spans = _a[0], indicates = _a[1];
    var newTemplate;
    if (ts.isNoSubstitutionTemplateLiteral(template)) {
        newTemplate = ts.factory.createNoSubstitutionTemplateLiteral(spans[0] || '');
    }
    else {
        var templateSpans_1 = template.templateSpans.slice();
        indicates.forEach(function (expressionIndex, iteration) {
            templateSpans_1.splice(expressionIndex - iteration, 1);
        });
        if (templateSpans_1.length === 0) {
            newTemplate = ts.factory.createNoSubstitutionTemplateLiteral(spans[0] || '');
        }
        else {
            newTemplate = ts.factory.createTemplateExpression(ts.factory.createTemplateHead(spans[0]), templateSpans_1.map(function (span, index) {
                return ts.factory.createTemplateSpan(span.expression, index === spans.length - 2
                    ? ts.factory.createTemplateTail(spans[index + 1])
                    : ts.factory.createTemplateMiddle(spans[index + 1]));
            }));
        }
    }
    return ts.factory.createTaggedTemplateExpression(node.tag, node.typeArguments, newTemplate);
}
//# sourceMappingURL=minifyTemplate.js.map